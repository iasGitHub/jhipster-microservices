{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, Output, Input, NgModule } from '@angular/core';\nimport { of, fromEvent } from 'rxjs';\nimport { mergeMap, map, tap, filter, throttleTime } from 'rxjs/operators';\n\nclass NgxInfiniteScrollService {\n  constructor() {}\n\n}\n\nNgxInfiniteScrollService.ɵfac = function NgxInfiniteScrollService_Factory(t) {\n  return new (t || NgxInfiniteScrollService)();\n};\n\nNgxInfiniteScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxInfiniteScrollService,\n  factory: NgxInfiniteScrollService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxInfiniteScrollService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n  const hasWindow = window && !!window.document && window.document.documentElement;\n  let container = hasWindow && scrollWindow ? window : defaultElement;\n\n  if (selector) {\n    const containerIsString = selector && hasWindow && typeof selector === 'string';\n    container = containerIsString ? findElement(selector, defaultElement.nativeElement, fromRoot) : selector;\n\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n\n  return container;\n}\n\nfunction findElement(selector, customRoot, fromRoot) {\n  const rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\n\nfunction inputPropChanged(prop) {\n  return prop && !prop.firstChange;\n}\n\nfunction hasWindowDefined() {\n  return typeof window !== 'undefined';\n}\n\nconst VerticalProps = {\n  clientHeight: \"clientHeight\",\n  offsetHeight: \"offsetHeight\",\n  scrollHeight: \"scrollHeight\",\n  pageYOffset: \"pageYOffset\",\n  offsetTop: \"offsetTop\",\n  scrollTop: \"scrollTop\",\n  top: \"top\"\n};\nconst HorizontalProps = {\n  clientHeight: \"clientWidth\",\n  offsetHeight: \"offsetWidth\",\n  scrollHeight: \"scrollWidth\",\n  pageYOffset: \"pageXOffset\",\n  offsetTop: \"offsetLeft\",\n  scrollTop: \"scrollLeft\",\n  top: \"left\"\n};\n\nclass AxisResolver {\n  constructor(vertical = true) {\n    this.vertical = vertical;\n    this.propsMap = vertical ? VerticalProps : HorizontalProps;\n  }\n\n  clientHeightKey() {\n    return this.propsMap.clientHeight;\n  }\n\n  offsetHeightKey() {\n    return this.propsMap.offsetHeight;\n  }\n\n  scrollHeightKey() {\n    return this.propsMap.scrollHeight;\n  }\n\n  pageYOffsetKey() {\n    return this.propsMap.pageYOffset;\n  }\n\n  offsetTopKey() {\n    return this.propsMap.offsetTop;\n  }\n\n  scrollTopKey() {\n    return this.propsMap.scrollTop;\n  }\n\n  topKey() {\n    return this.propsMap.top;\n  }\n\n}\n\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n  if (alwaysCallback && shouldFireScrollEvent) {\n    return true;\n  }\n\n  if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction createResolver({\n  windowElement,\n  axis\n}) {\n  return createResolverWithContainer({\n    axis,\n    isWindow: isElementWindow(windowElement)\n  }, windowElement);\n}\n\nfunction createResolverWithContainer(resolver, windowElement) {\n  const container = resolver.isWindow || windowElement && !windowElement.nativeElement ? windowElement : windowElement.nativeElement;\n  return Object.assign(Object.assign({}, resolver), {\n    container\n  });\n}\n\nfunction isElementWindow(windowElement) {\n  const isWindow = ['Window', 'global'].some(obj => Object.prototype.toString.call(windowElement).includes(obj));\n  return isWindow;\n}\n\nfunction getDocumentElement(isContainerWindow, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\n\nfunction calculatePoints(element, resolver) {\n  const height = extractHeightForElement(resolver);\n  return resolver.isWindow ? calculatePointsForWindow(height, element, resolver) : calculatePointsForElement(height, element, resolver);\n}\n\nfunction calculatePointsForWindow(height, element, resolver) {\n  const {\n    axis,\n    container,\n    isWindow\n  } = resolver;\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis); // scrolled until now / current y point\n\n  const scrolled = height + getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow); // total height / most bottom y point\n\n  const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n  const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow\n  };\n}\n\nfunction calculatePointsForElement(height, element, resolver) {\n  const {\n    axis,\n    container\n  } = resolver; // perhaps use container.offsetTop instead of 'scrollTop'\n\n  const scrolled = container[axis.scrollTopKey()];\n  const totalToScroll = container[axis.scrollHeightKey()];\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow: false\n  };\n}\n\nfunction extractHeightPropKeys(axis) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\n\nfunction extractHeightForElement({\n  container,\n  isWindow,\n  axis\n}) {\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis);\n  return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n  if (isNaN(elem[offsetHeightKey])) {\n    const docElem = getDocumentElement(isWindow, elem);\n    return docElem ? docElem[clientHeightKey] : 0;\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\n\nfunction getElementOffsetTop(elem, axis, isWindow) {\n  const topKey = axis.topKey(); // elem = elem.nativeElement;\n\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n\n  return elem.getBoundingClientRect()[topKey] + getElementPageYOffset(elem, axis, isWindow);\n}\n\nfunction getElementPageYOffset(elem, axis, isWindow) {\n  const pageYOffset = axis.pageYOffsetKey();\n  const scrollTop = axis.scrollTopKey();\n  const offsetTop = axis.offsetTopKey();\n\n  if (isNaN(window.pageYOffset)) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\n\nfunction shouldFireScrollEvent(container, distance = {\n  down: 0,\n  up: 0\n}, scrollingDown) {\n  let remaining;\n  let containerBreakpoint;\n\n  if (container.totalToScroll <= 0) {\n    return false;\n  }\n\n  const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n\n  if (scrollingDown) {\n    remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    const distanceDown = (distance === null || distance === void 0 ? void 0 : distance.down) ? distance.down : 0;\n    containerBreakpoint = distanceDown / 10;\n  } else {\n    const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n    remaining = container.scrolled / totalHiddenContentHeight;\n    const distanceUp = (distance === null || distance === void 0 ? void 0 : distance.up) ? distance.up : 0;\n    containerBreakpoint = distanceUp / 10;\n  }\n\n  const shouldFireEvent = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\n\nfunction isScrollingDownwards(lastScrollPosition, container) {\n  return lastScrollPosition < container.scrolled;\n}\n\nfunction getScrollStats(lastScrollPosition, container, distance) {\n  const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown\n  };\n}\n\nfunction updateScrollPosition(position, scrollState) {\n  return scrollState.lastScrollPosition = position;\n}\n\nfunction updateTotalToScroll(totalToScroll, scrollState) {\n  if (scrollState.lastTotalToScroll !== totalToScroll) {\n    scrollState.lastTotalToScroll = scrollState.totalToScroll;\n    scrollState.totalToScroll = totalToScroll;\n  }\n}\n\nfunction isSameTotalToScroll(scrollState) {\n  return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\n\nfunction updateTriggeredFlag(scroll, scrollState, triggered, isScrollingDown) {\n  if (isScrollingDown) {\n    scrollState.triggered.down = scroll;\n  } else {\n    scrollState.triggered.up = scroll;\n  }\n}\n\nfunction isTriggeredScroll(totalToScroll, scrollState, isScrollingDown) {\n  return isScrollingDown ? scrollState.triggered.down === totalToScroll : scrollState.triggered.up === totalToScroll;\n}\n\nfunction updateScrollState(scrollState, scrolledUntilNow, totalToScroll) {\n  updateScrollPosition(scrolledUntilNow, scrollState);\n  updateTotalToScroll(totalToScroll, scrollState); // const isSameTotal = isSameTotalToScroll(scrollState);\n  // if (!isSameTotal) {\n  //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n  // }\n}\n\nclass ScrollState {\n  constructor({\n    totalToScroll\n  }) {\n    this.lastScrollPosition = 0;\n    this.lastTotalToScroll = 0;\n    this.totalToScroll = 0;\n    this.triggered = {\n      down: 0,\n      up: 0\n    };\n    this.totalToScroll = totalToScroll;\n  }\n\n  updateScrollPosition(position) {\n    return this.lastScrollPosition = position;\n  }\n\n  updateTotalToScroll(totalToScroll) {\n    if (this.lastTotalToScroll !== totalToScroll) {\n      this.lastTotalToScroll = this.totalToScroll;\n      this.totalToScroll = totalToScroll;\n    }\n  }\n\n  updateScroll(scrolledUntilNow, totalToScroll) {\n    this.updateScrollPosition(scrolledUntilNow);\n    this.updateTotalToScroll(totalToScroll);\n  }\n\n  updateTriggeredFlag(scroll, isScrollingDown) {\n    if (isScrollingDown) {\n      this.triggered.down = scroll;\n    } else {\n      this.triggered.up = scroll;\n    }\n  }\n\n  isTriggeredScroll(totalToScroll, isScrollingDown) {\n    return isScrollingDown ? this.triggered.down === totalToScroll : this.triggered.up === totalToScroll;\n  }\n\n}\n\nfunction createScroller(config) {\n  const {\n    scrollContainer,\n    scrollWindow,\n    element,\n    fromRoot\n  } = config;\n  const resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n  });\n  const scrollState = new ScrollState({\n    totalToScroll: calculatePoints(element, resolver)\n  });\n  const options = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  const distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map(positionStats => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({\n    stats\n  }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({\n    fire,\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => {\n    scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n  }), map(toInfiniteScrollAction));\n}\n\nfunction attachScrollEvent(options) {\n  let obs = fromEvent(options.container, 'scroll'); // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n  // Let's avoid calling the function unless needed.\n  // Replacing with throttleTime seems to solve the problem\n  // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n\n  if (options.throttle) {\n    obs = obs.pipe(throttleTime(options.throttle, undefined, {\n      leading: true,\n      trailing: true\n    }));\n  }\n\n  return obs;\n}\n\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n  const {\n    scrollDown,\n    fire\n  } = getScrollStats(lastScrollPosition, stats, distance);\n  return {\n    scrollDown,\n    fire,\n    stats\n  };\n}\n\nconst InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\n\nfunction toInfiniteScrollAction(response) {\n  const {\n    scrollDown,\n    stats: {\n      scrolled: currentScrollPosition\n    }\n  } = response;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition\n    }\n  };\n}\n\nclass InfiniteScrollDirective {\n  constructor(element, zone) {\n    this.element = element;\n    this.zone = zone;\n    this.scrolled = new EventEmitter();\n    this.scrolledUp = new EventEmitter();\n    this.infiniteScrollDistance = 2;\n    this.infiniteScrollUpDistance = 1.5;\n    this.infiniteScrollThrottle = 150;\n    this.infiniteScrollDisabled = false;\n    this.infiniteScrollContainer = null;\n    this.scrollWindow = true;\n    this.immediateCheck = false;\n    this.horizontal = false;\n    this.alwaysCallback = false;\n    this.fromRoot = false;\n  }\n\n  ngAfterViewInit() {\n    if (!this.infiniteScrollDisabled) {\n      this.setup();\n    }\n  }\n\n  ngOnChanges({\n    infiniteScrollContainer,\n    infiniteScrollDisabled,\n    infiniteScrollDistance\n  }) {\n    const containerChanged = inputPropChanged(infiniteScrollContainer);\n    const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n    const distanceChanged = inputPropChanged(infiniteScrollDistance);\n    const shouldSetup = !disabledChanged && !this.infiniteScrollDisabled || disabledChanged && !infiniteScrollDisabled.currentValue || distanceChanged;\n\n    if (containerChanged || disabledChanged || distanceChanged) {\n      this.destroyScroller();\n\n      if (shouldSetup) {\n        this.setup();\n      }\n    }\n  }\n\n  setup() {\n    if (hasWindowDefined()) {\n      this.zone.runOutsideAngular(() => {\n        this.disposeScroller = createScroller({\n          fromRoot: this.fromRoot,\n          alwaysCallback: this.alwaysCallback,\n          disable: this.infiniteScrollDisabled,\n          downDistance: this.infiniteScrollDistance,\n          element: this.element,\n          horizontal: this.horizontal,\n          scrollContainer: this.infiniteScrollContainer,\n          scrollWindow: this.scrollWindow,\n          throttle: this.infiniteScrollThrottle,\n          upDistance: this.infiniteScrollUpDistance\n        }).subscribe(payload => this.zone.run(() => this.handleOnScroll(payload)));\n      });\n    }\n  }\n\n  handleOnScroll({\n    type,\n    payload\n  }) {\n    switch (type) {\n      case InfiniteScrollActions.DOWN:\n        return this.scrolled.emit(payload);\n\n      case InfiniteScrollActions.UP:\n        return this.scrolledUp.emit(payload);\n\n      default:\n        return;\n    }\n  }\n\n  ngOnDestroy() {\n    this.destroyScroller();\n  }\n\n  destroyScroller() {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\n\n}\n\nInfiniteScrollDirective.ɵfac = function InfiniteScrollDirective_Factory(t) {\n  return new (t || InfiniteScrollDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nInfiniteScrollDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: InfiniteScrollDirective,\n  selectors: [[\"\", \"infiniteScroll\", \"\"], [\"\", \"infinite-scroll\", \"\"], [\"\", \"data-infinite-scroll\", \"\"]],\n  inputs: {\n    infiniteScrollDistance: \"infiniteScrollDistance\",\n    infiniteScrollUpDistance: \"infiniteScrollUpDistance\",\n    infiniteScrollThrottle: \"infiniteScrollThrottle\",\n    infiniteScrollDisabled: \"infiniteScrollDisabled\",\n    infiniteScrollContainer: \"infiniteScrollContainer\",\n    scrollWindow: \"scrollWindow\",\n    immediateCheck: \"immediateCheck\",\n    horizontal: \"horizontal\",\n    alwaysCallback: \"alwaysCallback\",\n    fromRoot: \"fromRoot\"\n  },\n  outputs: {\n    scrolled: \"scrolled\",\n    scrolledUp: \"scrolledUp\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InfiniteScrollDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    scrolled: [{\n      type: Output\n    }],\n    scrolledUp: [{\n      type: Output\n    }],\n    infiniteScrollDistance: [{\n      type: Input\n    }],\n    infiniteScrollUpDistance: [{\n      type: Input\n    }],\n    infiniteScrollThrottle: [{\n      type: Input\n    }],\n    infiniteScrollDisabled: [{\n      type: Input\n    }],\n    infiniteScrollContainer: [{\n      type: Input\n    }],\n    scrollWindow: [{\n      type: Input\n    }],\n    immediateCheck: [{\n      type: Input\n    }],\n    horizontal: [{\n      type: Input\n    }],\n    alwaysCallback: [{\n      type: Input\n    }],\n    fromRoot: [{\n      type: Input\n    }]\n  });\n})();\n\nclass InfiniteScrollModule {}\n\nInfiniteScrollModule.ɵfac = function InfiniteScrollModule_Factory(t) {\n  return new (t || InfiniteScrollModule)();\n};\n\nInfiniteScrollModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: InfiniteScrollModule\n});\nInfiniteScrollModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InfiniteScrollModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [InfiniteScrollDirective],\n      exports: [InfiniteScrollDirective],\n      imports: [],\n      providers: []\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of ngx-infinite-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { InfiniteScrollDirective, InfiniteScrollModule, NgxInfiniteScrollService };","map":{"version":3,"names":["i0","Injectable","EventEmitter","Directive","Output","Input","NgModule","of","fromEvent","mergeMap","map","tap","filter","throttleTime","NgxInfiniteScrollService","constructor","ɵfac","ɵprov","type","args","providedIn","resolveContainerElement","selector","scrollWindow","defaultElement","fromRoot","hasWindow","window","document","documentElement","container","containerIsString","findElement","nativeElement","Error","customRoot","rootEl","querySelector","inputPropChanged","prop","firstChange","hasWindowDefined","VerticalProps","clientHeight","offsetHeight","scrollHeight","pageYOffset","offsetTop","scrollTop","top","HorizontalProps","AxisResolver","vertical","propsMap","clientHeightKey","offsetHeightKey","scrollHeightKey","pageYOffsetKey","offsetTopKey","scrollTopKey","topKey","shouldTriggerEvents","alwaysCallback","shouldFireScrollEvent","isTriggeredCurrentTotal","createResolver","windowElement","axis","createResolverWithContainer","isWindow","isElementWindow","resolver","Object","assign","some","obj","prototype","toString","call","includes","getDocumentElement","isContainerWindow","calculatePoints","element","height","extractHeightForElement","calculatePointsForWindow","calculatePointsForElement","extractHeightPropKeys","scrolled","getElementPageYOffset","nativeElementHeight","getElementHeight","totalToScroll","getElementOffsetTop","elem","isNaN","docElem","getBoundingClientRect","ownerDocument","defaultView","distance","down","up","scrollingDown","remaining","containerBreakpoint","scrolledUntilNow","distanceDown","totalHiddenContentHeight","distanceUp","shouldFireEvent","isScrollingDownwards","lastScrollPosition","getScrollStats","scrollDown","fire","updateScrollPosition","position","scrollState","updateTotalToScroll","lastTotalToScroll","isSameTotalToScroll","updateTriggeredFlag","scroll","triggered","isScrollingDown","isTriggeredScroll","updateScrollState","ScrollState","updateScroll","createScroller","config","scrollContainer","horizontal","options","throttle","upDistance","downDistance","attachScrollEvent","pipe","positionStats","toInfiniteScrollParams","stats","toInfiniteScrollAction","obs","undefined","leading","trailing","InfiniteScrollActions","DOWN","UP","response","currentScrollPosition","payload","InfiniteScrollDirective","zone","scrolledUp","infiniteScrollDistance","infiniteScrollUpDistance","infiniteScrollThrottle","infiniteScrollDisabled","infiniteScrollContainer","immediateCheck","ngAfterViewInit","setup","ngOnChanges","containerChanged","disabledChanged","distanceChanged","shouldSetup","currentValue","destroyScroller","runOutsideAngular","disposeScroller","disable","subscribe","run","handleOnScroll","emit","ngOnDestroy","unsubscribe","ElementRef","NgZone","ɵdir","InfiniteScrollModule","ɵmod","ɵinj","declarations","exports","imports","providers"],"sources":["/home/ias/2SI/GesMicroservice/gateway/node_modules/ngx-infinite-scroll/fesm2015/ngx-infinite-scroll.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, Output, Input, NgModule } from '@angular/core';\nimport { of, fromEvent } from 'rxjs';\nimport { mergeMap, map, tap, filter, throttleTime } from 'rxjs/operators';\n\nclass NgxInfiniteScrollService {\n    constructor() { }\n}\nNgxInfiniteScrollService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.0.5\", ngImport: i0, type: NgxInfiniteScrollService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNgxInfiniteScrollService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.0.5\", ngImport: i0, type: NgxInfiniteScrollService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.0.5\", ngImport: i0, type: NgxInfiniteScrollService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: function () { return []; } });\n\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n    const hasWindow = window && !!window.document && window.document.documentElement;\n    let container = hasWindow && scrollWindow ? window : defaultElement;\n    if (selector) {\n        const containerIsString = selector && hasWindow && typeof selector === 'string';\n        container = containerIsString\n            ? findElement(selector, defaultElement.nativeElement, fromRoot)\n            : selector;\n        if (!container) {\n            throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n        }\n    }\n    return container;\n}\nfunction findElement(selector, customRoot, fromRoot) {\n    const rootEl = fromRoot ? window.document : customRoot;\n    return rootEl.querySelector(selector);\n}\nfunction inputPropChanged(prop) {\n    return prop && !prop.firstChange;\n}\nfunction hasWindowDefined() {\n    return typeof window !== 'undefined';\n}\n\nconst VerticalProps = {\n    clientHeight: \"clientHeight\",\n    offsetHeight: \"offsetHeight\",\n    scrollHeight: \"scrollHeight\",\n    pageYOffset: \"pageYOffset\",\n    offsetTop: \"offsetTop\",\n    scrollTop: \"scrollTop\",\n    top: \"top\"\n};\nconst HorizontalProps = {\n    clientHeight: \"clientWidth\",\n    offsetHeight: \"offsetWidth\",\n    scrollHeight: \"scrollWidth\",\n    pageYOffset: \"pageXOffset\",\n    offsetTop: \"offsetLeft\",\n    scrollTop: \"scrollLeft\",\n    top: \"left\"\n};\nclass AxisResolver {\n    constructor(vertical = true) {\n        this.vertical = vertical;\n        this.propsMap = vertical ? VerticalProps : HorizontalProps;\n    }\n    clientHeightKey() {\n        return this.propsMap.clientHeight;\n    }\n    offsetHeightKey() {\n        return this.propsMap.offsetHeight;\n    }\n    scrollHeightKey() {\n        return this.propsMap.scrollHeight;\n    }\n    pageYOffsetKey() {\n        return this.propsMap.pageYOffset;\n    }\n    offsetTopKey() {\n        return this.propsMap.offsetTop;\n    }\n    scrollTopKey() {\n        return this.propsMap.scrollTop;\n    }\n    topKey() {\n        return this.propsMap.top;\n    }\n}\n\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n    if (alwaysCallback && shouldFireScrollEvent) {\n        return true;\n    }\n    if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n        return true;\n    }\n    return false;\n}\n\nfunction createResolver({ windowElement, axis, }) {\n    return createResolverWithContainer({ axis, isWindow: isElementWindow(windowElement) }, windowElement);\n}\nfunction createResolverWithContainer(resolver, windowElement) {\n    const container = resolver.isWindow || (windowElement && !windowElement.nativeElement)\n        ? windowElement\n        : windowElement.nativeElement;\n    return Object.assign(Object.assign({}, resolver), { container });\n}\nfunction isElementWindow(windowElement) {\n    const isWindow = ['Window', 'global'].some((obj) => Object.prototype.toString.call(windowElement).includes(obj));\n    return isWindow;\n}\nfunction getDocumentElement(isContainerWindow, windowElement) {\n    return isContainerWindow ? windowElement.document.documentElement : null;\n}\nfunction calculatePoints(element, resolver) {\n    const height = extractHeightForElement(resolver);\n    return resolver.isWindow\n        ? calculatePointsForWindow(height, element, resolver)\n        : calculatePointsForElement(height, element, resolver);\n}\nfunction calculatePointsForWindow(height, element, resolver) {\n    const { axis, container, isWindow } = resolver;\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    // scrolled until now / current y point\n    const scrolled = height +\n        getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n    // total height / most bottom y point\n    const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n    const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) +\n        nativeElementHeight;\n    return { height, scrolled, totalToScroll, isWindow };\n}\nfunction calculatePointsForElement(height, element, resolver) {\n    const { axis, container } = resolver;\n    // perhaps use container.offsetTop instead of 'scrollTop'\n    const scrolled = container[axis.scrollTopKey()];\n    const totalToScroll = container[axis.scrollHeightKey()];\n    return { height, scrolled, totalToScroll, isWindow: false };\n}\nfunction extractHeightPropKeys(axis) {\n    return {\n        offsetHeightKey: axis.offsetHeightKey(),\n        clientHeightKey: axis.clientHeightKey(),\n    };\n}\nfunction extractHeightForElement({ container, isWindow, axis, }) {\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n    if (isNaN(elem[offsetHeightKey])) {\n        const docElem = getDocumentElement(isWindow, elem);\n        return docElem ? docElem[clientHeightKey] : 0;\n    }\n    else {\n        return elem[offsetHeightKey];\n    }\n}\nfunction getElementOffsetTop(elem, axis, isWindow) {\n    const topKey = axis.topKey();\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) {\n        // || elem.css('none')) {\n        return;\n    }\n    return (elem.getBoundingClientRect()[topKey] +\n        getElementPageYOffset(elem, axis, isWindow));\n}\nfunction getElementPageYOffset(elem, axis, isWindow) {\n    const pageYOffset = axis.pageYOffsetKey();\n    const scrollTop = axis.scrollTopKey();\n    const offsetTop = axis.offsetTopKey();\n    if (isNaN(window.pageYOffset)) {\n        return getDocumentElement(isWindow, elem)[scrollTop];\n    }\n    else if (elem.ownerDocument) {\n        return elem.ownerDocument.defaultView[pageYOffset];\n    }\n    else {\n        return elem[offsetTop];\n    }\n}\n\nfunction shouldFireScrollEvent(container, distance = { down: 0, up: 0 }, scrollingDown) {\n    let remaining;\n    let containerBreakpoint;\n    if (container.totalToScroll <= 0) {\n        return false;\n    }\n    const scrolledUntilNow = container.isWindow\n        ? container.scrolled\n        : container.height + container.scrolled;\n    if (scrollingDown) {\n        remaining =\n            (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n        const distanceDown = (distance === null || distance === void 0 ? void 0 : distance.down) ? distance.down : 0;\n        containerBreakpoint = distanceDown / 10;\n    }\n    else {\n        const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n        remaining = container.scrolled / totalHiddenContentHeight;\n        const distanceUp = (distance === null || distance === void 0 ? void 0 : distance.up) ? distance.up : 0;\n        containerBreakpoint = distanceUp / 10;\n    }\n    const shouldFireEvent = remaining <= containerBreakpoint;\n    return shouldFireEvent;\n}\nfunction isScrollingDownwards(lastScrollPosition, container) {\n    return lastScrollPosition < container.scrolled;\n}\nfunction getScrollStats(lastScrollPosition, container, distance) {\n    const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n    return {\n        fire: shouldFireScrollEvent(container, distance, scrollDown),\n        scrollDown,\n    };\n}\nfunction updateScrollPosition(position, scrollState) {\n    return (scrollState.lastScrollPosition = position);\n}\nfunction updateTotalToScroll(totalToScroll, scrollState) {\n    if (scrollState.lastTotalToScroll !== totalToScroll) {\n        scrollState.lastTotalToScroll = scrollState.totalToScroll;\n        scrollState.totalToScroll = totalToScroll;\n    }\n}\nfunction isSameTotalToScroll(scrollState) {\n    return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\nfunction updateTriggeredFlag(scroll, scrollState, triggered, isScrollingDown) {\n    if (isScrollingDown) {\n        scrollState.triggered.down = scroll;\n    }\n    else {\n        scrollState.triggered.up = scroll;\n    }\n}\nfunction isTriggeredScroll(totalToScroll, scrollState, isScrollingDown) {\n    return isScrollingDown\n        ? scrollState.triggered.down === totalToScroll\n        : scrollState.triggered.up === totalToScroll;\n}\nfunction updateScrollState(scrollState, scrolledUntilNow, totalToScroll) {\n    updateScrollPosition(scrolledUntilNow, scrollState);\n    updateTotalToScroll(totalToScroll, scrollState);\n    // const isSameTotal = isSameTotalToScroll(scrollState);\n    // if (!isSameTotal) {\n    //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n    // }\n}\n\nclass ScrollState {\n    constructor({ totalToScroll }) {\n        this.lastScrollPosition = 0;\n        this.lastTotalToScroll = 0;\n        this.totalToScroll = 0;\n        this.triggered = {\n            down: 0,\n            up: 0,\n        };\n        this.totalToScroll = totalToScroll;\n    }\n    updateScrollPosition(position) {\n        return (this.lastScrollPosition = position);\n    }\n    updateTotalToScroll(totalToScroll) {\n        if (this.lastTotalToScroll !== totalToScroll) {\n            this.lastTotalToScroll = this.totalToScroll;\n            this.totalToScroll = totalToScroll;\n        }\n    }\n    updateScroll(scrolledUntilNow, totalToScroll) {\n        this.updateScrollPosition(scrolledUntilNow);\n        this.updateTotalToScroll(totalToScroll);\n    }\n    updateTriggeredFlag(scroll, isScrollingDown) {\n        if (isScrollingDown) {\n            this.triggered.down = scroll;\n        }\n        else {\n            this.triggered.up = scroll;\n        }\n    }\n    isTriggeredScroll(totalToScroll, isScrollingDown) {\n        return isScrollingDown\n            ? this.triggered.down === totalToScroll\n            : this.triggered.up === totalToScroll;\n    }\n}\n\nfunction createScroller(config) {\n    const { scrollContainer, scrollWindow, element, fromRoot } = config;\n    const resolver = createResolver({\n        axis: new AxisResolver(!config.horizontal),\n        windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot),\n    });\n    const scrollState = new ScrollState({\n        totalToScroll: calculatePoints(element, resolver),\n    });\n    const options = {\n        container: resolver.container,\n        throttle: config.throttle,\n    };\n    const distance = {\n        up: config.upDistance,\n        down: config.downDistance,\n    };\n    return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map((positionStats) => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({ stats }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({ fire, scrollDown, stats: { totalToScroll } }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({ scrollDown, stats: { totalToScroll } }) => {\n        scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n    }), map(toInfiniteScrollAction));\n}\nfunction attachScrollEvent(options) {\n    let obs = fromEvent(options.container, 'scroll');\n    // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n    // Let's avoid calling the function unless needed.\n    // Replacing with throttleTime seems to solve the problem\n    // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n    if (options.throttle) {\n        obs = obs.pipe(throttleTime(options.throttle, undefined, {\n            leading: true,\n            trailing: true,\n        }));\n    }\n    return obs;\n}\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n    const { scrollDown, fire } = getScrollStats(lastScrollPosition, stats, distance);\n    return {\n        scrollDown,\n        fire,\n        stats,\n    };\n}\nconst InfiniteScrollActions = {\n    DOWN: '[NGX_ISE] DOWN',\n    UP: '[NGX_ISE] UP',\n};\nfunction toInfiniteScrollAction(response) {\n    const { scrollDown, stats: { scrolled: currentScrollPosition }, } = response;\n    return {\n        type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n        payload: {\n            currentScrollPosition,\n        },\n    };\n}\n\nclass InfiniteScrollDirective {\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.scrolled = new EventEmitter();\n        this.scrolledUp = new EventEmitter();\n        this.infiniteScrollDistance = 2;\n        this.infiniteScrollUpDistance = 1.5;\n        this.infiniteScrollThrottle = 150;\n        this.infiniteScrollDisabled = false;\n        this.infiniteScrollContainer = null;\n        this.scrollWindow = true;\n        this.immediateCheck = false;\n        this.horizontal = false;\n        this.alwaysCallback = false;\n        this.fromRoot = false;\n    }\n    ngAfterViewInit() {\n        if (!this.infiniteScrollDisabled) {\n            this.setup();\n        }\n    }\n    ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance, }) {\n        const containerChanged = inputPropChanged(infiniteScrollContainer);\n        const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n        const distanceChanged = inputPropChanged(infiniteScrollDistance);\n        const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n            (disabledChanged && !infiniteScrollDisabled.currentValue) ||\n            distanceChanged;\n        if (containerChanged || disabledChanged || distanceChanged) {\n            this.destroyScroller();\n            if (shouldSetup) {\n                this.setup();\n            }\n        }\n    }\n    setup() {\n        if (hasWindowDefined()) {\n            this.zone.runOutsideAngular(() => {\n                this.disposeScroller = createScroller({\n                    fromRoot: this.fromRoot,\n                    alwaysCallback: this.alwaysCallback,\n                    disable: this.infiniteScrollDisabled,\n                    downDistance: this.infiniteScrollDistance,\n                    element: this.element,\n                    horizontal: this.horizontal,\n                    scrollContainer: this.infiniteScrollContainer,\n                    scrollWindow: this.scrollWindow,\n                    throttle: this.infiniteScrollThrottle,\n                    upDistance: this.infiniteScrollUpDistance,\n                }).subscribe((payload) => this.zone.run(() => this.handleOnScroll(payload)));\n            });\n        }\n    }\n    handleOnScroll({ type, payload }) {\n        switch (type) {\n            case InfiniteScrollActions.DOWN:\n                return this.scrolled.emit(payload);\n            case InfiniteScrollActions.UP:\n                return this.scrolledUp.emit(payload);\n            default:\n                return;\n        }\n    }\n    ngOnDestroy() {\n        this.destroyScroller();\n    }\n    destroyScroller() {\n        if (this.disposeScroller) {\n            this.disposeScroller.unsubscribe();\n        }\n    }\n}\nInfiniteScrollDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.0.5\", ngImport: i0, type: InfiniteScrollDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nInfiniteScrollDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.0.5\", type: InfiniteScrollDirective, selector: \"[infiniteScroll], [infinite-scroll], [data-infinite-scroll]\", inputs: { infiniteScrollDistance: \"infiniteScrollDistance\", infiniteScrollUpDistance: \"infiniteScrollUpDistance\", infiniteScrollThrottle: \"infiniteScrollThrottle\", infiniteScrollDisabled: \"infiniteScrollDisabled\", infiniteScrollContainer: \"infiniteScrollContainer\", scrollWindow: \"scrollWindow\", immediateCheck: \"immediateCheck\", horizontal: \"horizontal\", alwaysCallback: \"alwaysCallback\", fromRoot: \"fromRoot\" }, outputs: { scrolled: \"scrolled\", scrolledUp: \"scrolledUp\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.0.5\", ngImport: i0, type: InfiniteScrollDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { scrolled: [{\n                type: Output\n            }], scrolledUp: [{\n                type: Output\n            }], infiniteScrollDistance: [{\n                type: Input\n            }], infiniteScrollUpDistance: [{\n                type: Input\n            }], infiniteScrollThrottle: [{\n                type: Input\n            }], infiniteScrollDisabled: [{\n                type: Input\n            }], infiniteScrollContainer: [{\n                type: Input\n            }], scrollWindow: [{\n                type: Input\n            }], immediateCheck: [{\n                type: Input\n            }], horizontal: [{\n                type: Input\n            }], alwaysCallback: [{\n                type: Input\n            }], fromRoot: [{\n                type: Input\n            }] } });\n\nclass InfiniteScrollModule {\n}\nInfiniteScrollModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.0.5\", ngImport: i0, type: InfiniteScrollModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nInfiniteScrollModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.0.5\", ngImport: i0, type: InfiniteScrollModule, declarations: [InfiniteScrollDirective], exports: [InfiniteScrollDirective] });\nInfiniteScrollModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.0.5\", ngImport: i0, type: InfiniteScrollModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.0.5\", ngImport: i0, type: InfiniteScrollModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [InfiniteScrollDirective],\n                    exports: [InfiniteScrollDirective],\n                    imports: [],\n                    providers: [],\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-infinite-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InfiniteScrollDirective, InfiniteScrollModule, NgxInfiniteScrollService };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}