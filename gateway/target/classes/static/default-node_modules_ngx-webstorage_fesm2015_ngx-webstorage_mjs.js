"use strict";
(self["webpackChunkgateway"] = self["webpackChunkgateway"] || []).push([["default-node_modules_ngx-webstorage_fesm2015_ngx-webstorage_mjs"],{

/***/ 9930:
/*!*****************************************************************!*\
  !*** ./node_modules/ngx-webstorage/fesm2015/ngx-webstorage.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsyncStorage": () => (/* binding */ AsyncStorage),
/* harmony export */   "CompatHelper": () => (/* binding */ CompatHelper),
/* harmony export */   "InMemoryStorageStrategy": () => (/* binding */ InMemoryStorageStrategy),
/* harmony export */   "InvalidStrategyError": () => (/* binding */ InvalidStrategyError),
/* harmony export */   "LIB_CONFIG": () => (/* binding */ LIB_CONFIG),
/* harmony export */   "LOCAL_STORAGE": () => (/* binding */ LOCAL_STORAGE),
/* harmony export */   "LocalStorage": () => (/* binding */ LocalStorage),
/* harmony export */   "LocalStorageService": () => (/* binding */ LocalStorageService),
/* harmony export */   "LocalStorageStrategy": () => (/* binding */ LocalStorageStrategy),
/* harmony export */   "NgxWebstorageModule": () => (/* binding */ NgxWebstorageModule),
/* harmony export */   "SESSION_STORAGE": () => (/* binding */ SESSION_STORAGE),
/* harmony export */   "STORAGE_STRATEGIES": () => (/* binding */ STORAGE_STRATEGIES),
/* harmony export */   "SessionStorage": () => (/* binding */ SessionStorage),
/* harmony export */   "SessionStorageService": () => (/* binding */ SessionStorageService),
/* harmony export */   "SessionStorageStrategy": () => (/* binding */ SessionStorageStrategy),
/* harmony export */   "StorageStrategies": () => (/* binding */ StorageStrategies),
/* harmony export */   "StorageStrategyStub": () => (/* binding */ StorageStrategyStub),
/* harmony export */   "StorageStrategyStubName": () => (/* binding */ StorageStrategyStubName),
/* harmony export */   "StorageStub": () => (/* binding */ StorageStub),
/* harmony export */   "StrategyCacheService": () => (/* binding */ StrategyCacheService),
/* harmony export */   "StrategyIndex": () => (/* binding */ StrategyIndex),
/* harmony export */   "SyncStorage": () => (/* binding */ SyncStorage),
/* harmony export */   "appInit": () => (/* binding */ appInit)
/* harmony export */ });
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs/operators */ 2070);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 704);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 4125);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ 3013);





var StorageStrategies;

(function (StorageStrategies) {
  StorageStrategies["Local"] = "local_strategy";
  StorageStrategies["Session"] = "session_strategy";
  StorageStrategies["InMemory"] = "in_memory_strategy";
})(StorageStrategies || (StorageStrategies = {}));

class CompatHelper {
  static isStorageAvailable(storage) {
    let available = true;

    try {
      if (typeof storage === 'object') {
        storage.setItem('test-storage', 'foobar');
        storage.removeItem('test-storage');
      } else available = false;
    } catch (e) {
      available = false;
    }

    return available;
  }

}

function noop() {}

const DefaultPrefix = 'ngx-webstorage';
const DefaultSeparator = '|';
const DefaultIsCaseSensitive = false;

class StorageKeyManager {
  static normalize(raw) {
    raw = StorageKeyManager.isCaseSensitive ? raw : raw.toLowerCase();
    return `${StorageKeyManager.prefix}${StorageKeyManager.separator}${raw}`;
  }

  static isNormalizedKey(key) {
    return key.indexOf(StorageKeyManager.prefix + StorageKeyManager.separator) === 0;
  }

  static setPrefix(prefix) {
    StorageKeyManager.prefix = prefix;
  }

  static setSeparator(separator) {
    StorageKeyManager.separator = separator;
  }

  static setCaseSensitive(enable) {
    StorageKeyManager.isCaseSensitive = enable;
  }

  static consumeConfiguration(config) {
    if ('prefix' in config) this.setPrefix(config.prefix);
    if ('separator' in config) this.setSeparator(config.separator);
    if ('caseSensitive' in config) this.setCaseSensitive(config.caseSensitive);
  }

}

StorageKeyManager.prefix = DefaultPrefix;
StorageKeyManager.separator = DefaultSeparator;
StorageKeyManager.isCaseSensitive = DefaultIsCaseSensitive;

class SyncStorage {
  constructor(strategy) {
    this.strategy = strategy;
  }

  retrieve(key) {
    let value;
    this.strategy.get(StorageKeyManager.normalize(key)).subscribe(result => value = typeof result === 'undefined' ? null : result);
    return value;
  }

  store(key, value) {
    this.strategy.set(StorageKeyManager.normalize(key), value).subscribe(noop);
    return value;
  }

  clear(key) {
    if (key !== undefined) this.strategy.del(StorageKeyManager.normalize(key)).subscribe(noop);else this.strategy.clear().subscribe(noop);
  }

  getStrategyName() {
    return this.strategy.name;
  }

  observe(key) {
    key = StorageKeyManager.normalize(key);
    return this.strategy.keyChanges.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.filter)(changed => changed === null || changed === key), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.switchMap)(() => this.strategy.get(key)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.distinctUntilChanged)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.shareReplay)({
      refCount: true,
      bufferSize: 1
    }));
  }

}

class AsyncStorage {
  constructor(strategy) {
    this.strategy = strategy;
  }

  retrieve(key) {
    return this.strategy.get(StorageKeyManager.normalize(key)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.map)(value => typeof value === 'undefined' ? null : value));
  }

  store(key, value) {
    return this.strategy.set(StorageKeyManager.normalize(key), value);
  }

  clear(key) {
    return key !== undefined ? this.strategy.del(StorageKeyManager.normalize(key)) : this.strategy.clear();
  }

  getStrategyName() {
    return this.strategy.name;
  }

  observe(key) {
    key = StorageKeyManager.normalize(key);
    return this.strategy.keyChanges.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.filter)(changed => changed === null || changed === key), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.switchMap)(() => this.strategy.get(key)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.distinctUntilChanged)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.shareReplay)({
      refCount: true,
      bufferSize: 1
    }));
  }

}

class StrategyCacheService {
  constructor() {
    this.caches = {};
  }

  get(strategyName, key) {
    return this.getCacheStore(strategyName)[key];
  }

  set(strategyName, key, value) {
    this.getCacheStore(strategyName)[key] = value;
  }

  del(strategyName, key) {
    delete this.getCacheStore(strategyName)[key];
  }

  clear(strategyName) {
    this.caches[strategyName] = {};
  }

  getCacheStore(strategyName) {
    if (strategyName in this.caches) return this.caches[strategyName];
    return this.caches[strategyName] = {};
  }

}

StrategyCacheService.ɵfac = function StrategyCacheService_Factory(t) {
  return new (t || StrategyCacheService)();
};

StrategyCacheService.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
  token: StrategyCacheService,
  factory: StrategyCacheService.ɵfac,
  providedIn: 'root'
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](StrategyCacheService, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();

const LOCAL_STORAGE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('window_local_storage');

function getLocalStorage() {
  return typeof window !== 'undefined' ? window.localStorage : null;
}

const LocalStorageProvider = {
  provide: LOCAL_STORAGE,
  useFactory: getLocalStorage
};
const SESSION_STORAGE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('window_session_storage');

function getSessionStorage() {
  return typeof window !== 'undefined' ? window.sessionStorage : null;
}

const SessionStorageProvider = {
  provide: SESSION_STORAGE,
  useFactory: getSessionStorage
};

class BaseSyncStorageStrategy {
  constructor(storage, cache) {
    this.storage = storage;
    this.cache = cache;
    this.keyChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
  }

  get isAvailable() {
    if (this._isAvailable === undefined) this._isAvailable = CompatHelper.isStorageAvailable(this.storage);
    return this._isAvailable;
  }

  get(key) {
    let data = this.cache.get(this.name, key);
    if (data !== undefined) return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(data);

    try {
      const item = this.storage.getItem(key);

      if (item !== null) {
        data = JSON.parse(item);
        this.cache.set(this.name, key, data);
      }
    } catch (err) {
      console.warn(err);
    }

    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(data);
  }

  set(key, value) {
    const data = JSON.stringify(value);
    this.storage.setItem(key, data);
    this.cache.set(this.name, key, value);
    this.keyChanges.next(key);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(value);
  }

  del(key) {
    this.storage.removeItem(key);
    this.cache.del(this.name, key);
    this.keyChanges.next(key);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(null);
  }

  clear() {
    this.storage.clear();
    this.cache.clear(this.name);
    this.keyChanges.next(null);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(null);
  }

}

class LocalStorageStrategy extends BaseSyncStorageStrategy {
  constructor(storage, cache, platformId, zone) {
    super(storage, cache);
    this.storage = storage;
    this.cache = cache;
    this.platformId = platformId;
    this.zone = zone;
    this.name = LocalStorageStrategy.strategyName;
    if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_3__.isPlatformBrowser)(this.platformId)) this.listenExternalChanges();
  }

  listenExternalChanges() {
    window.addEventListener('storage', event => this.zone.run(() => {
      if (event.storageArea !== this.storage) return;
      const key = event.key;
      if (key !== null) this.cache.del(this.name, event.key);else this.cache.clear(this.name);
      this.keyChanges.next(key);
    }));
  }

}

LocalStorageStrategy.strategyName = StorageStrategies.Local;

LocalStorageStrategy.ɵfac = function LocalStorageStrategy_Factory(t) {
  return new (t || LocalStorageStrategy)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](LOCAL_STORAGE), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](StrategyCacheService), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone));
};

LocalStorageStrategy.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
  token: LocalStorageStrategy,
  factory: LocalStorageStrategy.ɵfac
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](LocalStorageStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [LOCAL_STORAGE]
      }]
    }, {
      type: StrategyCacheService
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID]
      }]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone
    }];
  }, null);
})();

class SessionStorageStrategy extends BaseSyncStorageStrategy {
  constructor(storage, cache, platformId, zone) {
    super(storage, cache);
    this.storage = storage;
    this.cache = cache;
    this.platformId = platformId;
    this.zone = zone;
    this.name = SessionStorageStrategy.strategyName;
    if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_3__.isPlatformBrowser)(this.platformId)) this.listenExternalChanges();
  }

  listenExternalChanges() {
    window.addEventListener('storage', event => this.zone.run(() => {
      if (event.storageArea !== this.storage) return;
      const key = event.key;
      if (event.key !== null) this.cache.del(this.name, event.key);else this.cache.clear(this.name);
      this.keyChanges.next(key);
    }));
  }

}

SessionStorageStrategy.strategyName = StorageStrategies.Session;

SessionStorageStrategy.ɵfac = function SessionStorageStrategy_Factory(t) {
  return new (t || SessionStorageStrategy)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](SESSION_STORAGE), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](StrategyCacheService), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone));
};

SessionStorageStrategy.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
  token: SessionStorageStrategy,
  factory: SessionStorageStrategy.ɵfac
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](SessionStorageStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [SESSION_STORAGE]
      }]
    }, {
      type: StrategyCacheService
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID]
      }]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone
    }];
  }, null);
})();

class InMemoryStorageStrategy {
  constructor(cache) {
    this.cache = cache;
    this.keyChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
    this.isAvailable = true;
    this.name = InMemoryStorageStrategy.strategyName;
  }

  get(key) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(this.cache.get(this.name, key));
  }

  set(key, value) {
    this.cache.set(this.name, key, value);
    this.keyChanges.next(key);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(value);
  }

  del(key) {
    this.cache.del(this.name, key);
    this.keyChanges.next(key);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(null);
  }

  clear() {
    this.cache.clear(this.name);
    this.keyChanges.next(null);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(null);
  }

}

InMemoryStorageStrategy.strategyName = StorageStrategies.InMemory;

InMemoryStorageStrategy.ɵfac = function InMemoryStorageStrategy_Factory(t) {
  return new (t || InMemoryStorageStrategy)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](StrategyCacheService));
};

InMemoryStorageStrategy.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
  token: InMemoryStorageStrategy,
  factory: InMemoryStorageStrategy.ɵfac
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](InMemoryStorageStrategy, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable
  }], function () {
    return [{
      type: StrategyCacheService,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [StrategyCacheService]
      }]
    }];
  }, null);
})();

const STORAGE_STRATEGIES = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('STORAGE_STRATEGIES');
const Strategies = [{
  provide: STORAGE_STRATEGIES,
  useClass: InMemoryStorageStrategy,
  multi: true
}, {
  provide: STORAGE_STRATEGIES,
  useClass: LocalStorageStrategy,
  multi: true
}, {
  provide: STORAGE_STRATEGIES,
  useClass: SessionStorageStrategy,
  multi: true
}];
const StorageStrategyStubName = 'stub_strategy';

class StorageStrategyStub {
  constructor(name) {
    this.keyChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
    this.store = {};
    this._available = true;
    this.name = name || StorageStrategyStubName;
  }

  get isAvailable() {
    return this._available;
  }

  get(key) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(this.store[key]);
  }

  set(key, value) {
    this.store[key] = value;
    this.keyChanges.next(key);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(value);
  }

  del(key) {
    delete this.store[key];
    this.keyChanges.next(key);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(null);
  }

  clear() {
    this.store = {};
    this.keyChanges.next(null);
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(null);
  }

}

class StorageStub {
  constructor() {
    this.store = {};
  }

  get length() {
    return Object.keys(this.store).length;
  }

  clear() {
    this.store = {};
  }

  getItem(key) {
    return this.store[key] || null;
  }

  key(index) {
    return Object.keys(this.store)[index];
  }

  removeItem(key) {
    delete this.store[key];
  }

  setItem(key, value) {
    this.store[key] = value;
  }

}

const InvalidStrategyError = 'invalid_strategy';

class StrategyIndex {
  constructor(strategies) {
    this.strategies = strategies;
    this.registration$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
    if (!strategies) strategies = [];
    this.strategies = strategies.reverse().map((strategy, index, arr) => strategy.name).map((name, index, arr) => arr.indexOf(name) === index ? index : null).filter(index => index !== null).map(index => strategies[index]);
  }

  static get(name) {
    if (!this.isStrategyRegistered(name)) throw Error(InvalidStrategyError);
    let strategy = this.index[name];

    if (!strategy.isAvailable) {
      strategy = this.index[StorageStrategies.InMemory];
    }

    return strategy;
  }

  static set(name, strategy) {
    this.index[name] = strategy;
  }

  static clear(name) {
    if (name !== undefined) delete this.index[name];else this.index = {};
  }

  static isStrategyRegistered(name) {
    return name in this.index;
  }

  static hasRegistredStrategies() {
    return Object.keys(this.index).length > 0;
  }

  getStrategy(name) {
    return StrategyIndex.get(name);
  }

  indexStrategies() {
    this.strategies.forEach(strategy => this.register(strategy.name, strategy));
  }

  indexStrategy(name, overrideIfExists = false) {
    if (StrategyIndex.isStrategyRegistered(name) && !overrideIfExists) return StrategyIndex.get(name);
    const strategy = this.strategies.find(strategy => strategy.name === name);
    if (!strategy) throw new Error(InvalidStrategyError);
    this.register(name, strategy, overrideIfExists);
    return strategy;
  }

  register(name, strategy, overrideIfExists = false) {
    if (!StrategyIndex.isStrategyRegistered(name) || overrideIfExists) {
      StrategyIndex.set(name, strategy);
      this.registration$.next(name);
    }
  }

}

StrategyIndex.index = {};

StrategyIndex.ɵfac = function StrategyIndex_Factory(t) {
  return new (t || StrategyIndex)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](STORAGE_STRATEGIES, 8));
};

StrategyIndex.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
  token: StrategyIndex,
  factory: StrategyIndex.ɵfac,
  providedIn: 'root'
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](StrategyIndex, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [STORAGE_STRATEGIES]
      }]
    }];
  }, null);
})();

class LocalStorageService extends SyncStorage {}

function buildService$1(index) {
  const strategy = index.indexStrategy(StorageStrategies.Local);
  return new SyncStorage(strategy);
}

const LocalStorageServiceProvider = {
  provide: LocalStorageService,
  useFactory: buildService$1,
  deps: [StrategyIndex]
};

class SessionStorageService extends SyncStorage {}

function buildService(index) {
  const strategy = index.indexStrategy(StorageStrategies.Session);
  return new SyncStorage(strategy);
}

const SessionStorageServiceProvider = {
  provide: SessionStorageService,
  useFactory: buildService,
  deps: [StrategyIndex]
};

class DecoratorBuilder {
  static buildSyncStrategyDecorator(strategyName, prototype, propName, key, defaultValue = null) {
    const rawKey = key || propName;
    let storageKey;
    Object.defineProperty(prototype, propName, {
      get: function () {
        let value;
        StrategyIndex.get(strategyName).get(getKey()).subscribe(result => value = result);
        return value === undefined ? defaultValue : value;
      },
      set: function (value) {
        StrategyIndex.get(strategyName).set(getKey(), value).subscribe(noop);
      }
    });

    function getKey() {
      if (storageKey !== undefined) return storageKey;
      return storageKey = StorageKeyManager.normalize(rawKey);
    }
  }

}

function LocalStorage(key, defaultValue) {
  return function (prototype, propName) {
    DecoratorBuilder.buildSyncStrategyDecorator(StorageStrategies.Local, prototype, propName, key, defaultValue);
  };
}

function SessionStorage(key, defaultValue) {
  return function (prototype, propName) {
    DecoratorBuilder.buildSyncStrategyDecorator(StorageStrategies.Session, prototype, propName, key, defaultValue);
  };
}

const Services = [LocalStorageServiceProvider, SessionStorageServiceProvider];
const LIB_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('ngx_webstorage_config');

function appInit(index) {
  index.indexStrategies();
  return () => StrategyIndex.index;
}

class NgxWebstorageModule {
  constructor(index, config) {
    if (config) StorageKeyManager.consumeConfiguration(config);else console.error('NgxWebstorage : Possible misconfiguration (The forRoot method usage is mandatory since the 3.0.0)');
  }

  static forRoot(config = {}) {
    return {
      ngModule: NgxWebstorageModule,
      providers: [{
        provide: LIB_CONFIG,
        useValue: config
      }, LocalStorageProvider, SessionStorageProvider, ...Services, ...Strategies, {
        provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_INITIALIZER,
        useFactory: appInit,
        deps: [StrategyIndex],
        multi: true
      }]
    };
  }

}

NgxWebstorageModule.ɵfac = function NgxWebstorageModule_Factory(t) {
  return new (t || NgxWebstorageModule)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](StrategyIndex), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](LIB_CONFIG, 8));
};

NgxWebstorageModule.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
  type: NgxWebstorageModule
});
NgxWebstorageModule.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](NgxWebstorageModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
    args: [{}]
  }], function () {
    return [{
      type: StrategyIndex
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [LIB_CONFIG]
      }]
    }];
  }, null);
})();
/*
 * Public API Surface of ngx-webstorage
 */

/**
 * Generated bundle index. Do not edit.
 */




/***/ })

}]);
//# sourceMappingURL=default-node_modules_ngx-webstorage_fesm2015_ngx-webstorage_mjs.js.map